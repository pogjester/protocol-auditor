#!/usr/bin/env python3

import os
import git
import json
import datetime
from typing import List, Dict, Any
from dataclasses import dataclass
from pathlib import Path
import openai
from concurrent.futures import ThreadPoolExecutor
import logging
from dotenv import load_dotenv
import time
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@retry(
    retry=retry_if_exception_type((openai.RateLimitError, openai.APIError)),
    wait=wait_exponential(multiplier=1, min=4, max=60),
    stop=stop_after_attempt(5)
)
def call_openai_with_retry(client: openai.OpenAI, **kwargs) -> Any:
    """Make OpenAI API call with retry logic."""
    try:
        return client.chat.completions.create(**kwargs)
    except openai.RateLimitError:
        logger.warning("Rate limit hit, retrying after exponential backoff...")
        raise
    except openai.APIError as e:
        logger.warning(f"OpenAI API error: {str(e)}, retrying...")
        raise

@dataclass
class Vulnerability:
    title: str
    description: str
    severity: str  # High, Medium, Low
    affected_files: List[str]
    attack_vector: str
    potential_impact: str
    recommendation: str

class DefiProtocolAuditor:
    def __init__(self, repo_url: str, openai_api_key: str):
        self.repo_url = repo_url
        self.repo_path = None
        self.vulnerabilities: List[Vulnerability] = []
        
    def clone_repository(self, target_dir: str) -> None:
        """Clone the target repository to analyze."""
        logger.info(f"Cloning repository: {self.repo_url}")
        self.repo_path = Path(target_dir)
        if not self.repo_path.exists():
            git.Repo.clone_from(self.repo_url, target_dir)
        
    def get_smart_contracts(self) -> List[Path]:
        """Identify all smart contract files in the repository."""
        contract_files = []
        for ext in ['.sol', '.vy']:  # Solidity and Vyper files
            contract_files.extend(self.repo_path.rglob(f'*{ext}'))
        return contract_files

    def analyze_contract(self, contract_path: Path) -> Dict[str, Any]:
        """Analyze a single smart contract for potential vulnerabilities."""
        with open(contract_path, 'r') as f:
            content = f.read()
            
        prompt = f"""Analyze this smart contract for potential security vulnerabilities:
        
        Contract: {contract_path.name}
        Content: {content}
        
        Focus on:
        1. Reentrancy vulnerabilities
        2. Access control issues
        3. Integer overflow/underflow
        4. Flash loan attack vectors
        5. Price manipulation vulnerabilities
        6. Logic errors in financial calculations
        7. Centralization risks
        8. Cross-contract interaction risks
        
        Provide a detailed analysis in JSON format with found vulnerabilities."""

        client = openai.OpenAI()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are a smart contract security auditor."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1500,
            temperature=0.7
        )
        print(response)
        

    def analyze_system_interactions(self, contracts: List[Path]) -> Dict[str, Any]:
        """Analyze interactions between contracts and system-wide vulnerabilities."""
        contract_contents = []
        for contract in contracts:
            with open(contract, 'r') as f:
                contract_contents.append(f"{contract.name}: {f.read()}")
        
        system_prompt = f"""Analyze these smart contracts as a complete system and return the results in the following JSON format:

        {{
            "system_vulnerabilities": [
                {{
                    "title": "Vulnerability name",
                    "description": "Detailed description",
                    "severity": "High/Medium/Low",
                    "affected_files": ["file names"],
                    "attack_vector": "How the vulnerability can be exploited",
                    "potential_impact": "Impact description",
                    "recommendation": "How to fix"
                }}
            ]
        }}
        
        Contracts to analyze:
        {contract_contents}
        
        Focus on:
        1. Cross-contract reentrancy
        2. Privilege escalation across contracts
        3. Economic attack vectors
        4. Composability risks
        5. Protocol-wide invariants
        6. MEV opportunities
        7. Oracle manipulation possibilities
        8. Governance attack vectors
        
        Return ONLY valid JSON, no additional text or explanations."""

        client = openai.OpenAI()
        try:
            response = call_openai_with_retry(
                client,
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are a smart contract system auditor. Always respond with valid JSON."},
                    {"role": "user", "content": system_prompt}
                ],
                max_tokens=1500,
                temperature=0.7,
                response_format={ "type": "json_object" }
            )
            
            if not response.choices or not response.choices[0].message.content.strip():
                logger.error("Received empty response from OpenAI API")
                return {"system_vulnerabilities": []}
            
            return json.loads(response.choices[0].message.content)
            
        except Exception as e:
            logger.error(f"Error during system analysis: {e}")
            return {"system_vulnerabilities": []}

    def generate_report(self) -> str:
        """Generate a comprehensive security audit report."""
        report = {
            "repository": self.repo_url,
            "vulnerabilities": self.vulnerabilities,
            "timestamp": str(datetime.datetime.now()),
            "summary": {
                "high_severity": len([v for v in self.vulnerabilities if v.severity == "High"]),
                "medium_severity": len([v for v in self.vulnerabilities if v.severity == "Medium"]),
                "low_severity": len([v for v in self.vulnerabilities if v.severity == "Low"])
            }
        }
        return json.dumps(report, indent=2)

    def audit(self, target_dir: str) -> str:
        """Main method to perform the complete security audit."""
        try:
            # Clone and analyze repository
            self.clone_repository(target_dir)
            contracts = self.get_smart_contracts()
            
            # Analyze individual contracts
            with ThreadPoolExecutor() as executor:
                contract_analyses = list(executor.map(self.analyze_contract, contracts))
            
            # Analyze system-wide interactions
            system_analysis = self.analyze_system_interactions(contracts)
            
            # Process and combine results
            self._process_results(contract_analyses, system_analysis)
            
            # Generate and return report
            return self.generate_report()
            
        except Exception as e:
            logger.error(f"Error during audit: {str(e)}")
            raise

    def _process_results(self, contract_analyses: List[Dict], system_analysis: Dict) -> None:
        """Process and combine individual contract and system-wide analyses."""
        # Process individual contract vulnerabilities
        for analysis in contract_analyses:
            for vuln in analysis.get('vulnerabilities', []):
                self.vulnerabilities.append(
                    Vulnerability(
                        title=vuln['title'],
                        description=vuln['description'],
                        severity=vuln['severity'],
                        affected_files=vuln['affected_files'],
                        attack_vector=vuln['attack_vector'],
                        potential_impact=vuln['potential_impact'],
                        recommendation=vuln['recommendation']
                    )
                )
        
        # Process system-wide vulnerabilities
        for vuln in system_analysis.get('system_vulnerabilities', []):
            self.vulnerabilities.append(
                Vulnerability(
                    title=vuln['title'],
                    description=vuln['description'],
                    severity=vuln['severity'],
                    affected_files=vuln['affected_files'],
                    attack_vector=vuln['attack_vector'],
                    potential_impact=vuln['potential_impact'],
                    recommendation=vuln['recommendation']
                )
            )

def main():
    """Main entry point for the DeFi protocol auditor."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Analyze a DeFi protocol for security vulnerabilities')
    parser.add_argument('repo_url', help='URL of the GitHub repository to analyze')
    parser.add_argument('--output', help='Output file for the audit report', default='audit_report.json')
    
    args = parser.parse_args()
    
    openai_key = os.getenv('OPENAI_API_KEY')
    if not openai_key:
        raise ValueError("OPENAI_API_KEY environment variable must be set")
    
    auditor = DefiProtocolAuditor(args.repo_url, openai_key)
    report = auditor.audit('target_repo')
    
    with open(args.output, 'w') as f:
        f.write(report)
    
    logger.info(f"Audit complete. Report saved to {args.output}")

if __name__ == "__main__":
    main()
